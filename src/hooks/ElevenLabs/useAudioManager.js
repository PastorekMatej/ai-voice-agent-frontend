// useAudioManager.js\n// Hook for managing audio recording and playback\n\nimport { useState, useRef, useCallback } from 'react';\n\nconst useAudioManager = () => {\n  const [hasPermission, setHasPermission] = useState(false);\n  const [isRecording, setIsRecording] = useState(false);\n  const [error, setError] = useState(null);\n  \n  const mediaRecorderRef = useRef(null);\n  const audioStreamRef = useRef(null);\n  const audioChunksRef = useRef([]);\n\n  // Request microphone permission\n  const requestPermission = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      audioStreamRef.current = stream;\n      setHasPermission(true);\n      setError(null);\n      return true;\n    } catch (err) {\n      console.error('Microphone permission denied:', err);\n      setError('Microphone permission denied');\n      setHasPermission(false);\n      return false;\n    }\n  }, []);\n\n  // Start recording\n  const startRecording = useCallback(async () => {\n    if (!hasPermission) {\n      const granted = await requestPermission();\n      if (!granted) return false;\n    }\n\n    try {\n      if (!audioStreamRef.current) {\n        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n        audioStreamRef.current = stream;\n      }\n\n      // Reset audio chunks\n      audioChunksRef.current = [];\n\n      // Create MediaRecorder\n      mediaRecorderRef.current = new MediaRecorder(audioStreamRef.current);\n      \n      mediaRecorderRef.current.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          audioChunksRef.current.push(event.data);\n        }\n      };\n\n      mediaRecorderRef.current.start(100); // Collect data every 100ms\n      setIsRecording(true);\n      setError(null);\n      return true;\n    } catch (err) {\n      console.error('Failed to start recording:', err);\n      setError('Failed to start recording');\n      return false;\n    }\n  }, [hasPermission, requestPermission]);\n\n  // Stop recording\n  const stopRecording = useCallback(() => {\n    return new Promise((resolve) => {\n      if (mediaRecorderRef.current && isRecording) {\n        mediaRecorderRef.current.onstop = () => {\n          const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/wav' });\n          setIsRecording(false);\n          resolve(audioBlob);\n        };\n        \n        mediaRecorderRef.current.stop();\n      } else {\n        setIsRecording(false);\n        resolve(null);\n      }\n    });\n  }, [isRecording]);\n\n  // Get audio chunks for streaming (for real-time processing)\n  const getAudioChunks = useCallback(() => {\n    return audioChunksRef.current;\n  }, []);\n\n  // Cleanup resources\n  const cleanup = useCallback(() => {\n    if (audioStreamRef.current) {\n      audioStreamRef.current.getTracks().forEach(track => track.stop());\n      audioStreamRef.current = null;\n    }\n    \n    if (mediaRecorderRef.current) {\n      mediaRecorderRef.current = null;\n    }\n    \n    setIsRecording(false);\n    setHasPermission(false);\n    audioChunksRef.current = [];\n  }, []);\n\n  return {\n    hasPermission,\n    isRecording,\n    error,\n    requestPermission,\n    startRecording,\n    stopRecording,\n    getAudioChunks,\n    cleanup\n  };\n};\n\nexport default useAudioManager; 